Homework 1
================
Ruby He
2025-09-12

## Problem 1

### Load libraries and dataset

``` r
library(moderndive)
library(tidyverse)
```

    ## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
    ## ✔ dplyr     1.1.4     ✔ readr     2.1.5
    ## ✔ forcats   1.0.0     ✔ stringr   1.5.1
    ## ✔ ggplot2   3.5.2     ✔ tibble    3.3.0
    ## ✔ lubridate 1.9.4     ✔ tidyr     1.3.1
    ## ✔ purrr     1.1.0     
    ## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
    ## ✖ dplyr::filter() masks stats::filter()
    ## ✖ dplyr::lag()    masks stats::lag()
    ## ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors

``` r
data(early_january_weather) 
```

### Description of Dataset

This dataset has 15 variables and 358 observations.

The variables in this dataset are origin, year, month, day, hour, temp,
dewp, humid, wind_dir, wind_speed, wind_gust, precip, pressure, visib,
time_hour.

Key variable values include:

- `origin`: weather station (either LGA, JFK, or EWR)
- `year, month, day, hour, time_hour`: time (year, month, day, hour) of
  recording of the measurement
- `temp` and `dewp`: temperature and dewpoint in Fahrenheit
- `humid`: relative humidity as percentage.
- `wind_dr, wind_speed, and wind_gust`: wind direction in degrees, and
  wind speed and gust in miles per hour.
- `precip`: precipitation in inches
- `pressure`: sea level pressure in milibars
- `visib`: the visibility in miles

The mean temperature is 39.5821229.

### Scatterplot

``` r
ggplot(early_january_weather, aes(x = time_hour, y = temp, color = humid)) + geom_point()
```

![](p8105_hw1_yh3824_files/figure-gfm/unnamed-chunk-2-1.png)<!-- -->

In the scatterplot we can see that temperature rises as the time
increases. We can also see that humidity also seems to increase as the
temperature rises as well.

### Saving the scatterplot

``` r
ggsave("sctplot_time_temp.pdf",height = 4, width = 6)
```

## Problem 2

### Making the dataframe

``` r
prob2_df =
  tibble(
    num_samp = rnorm (10),
    greater_0 = num_samp > 0,
    shapes = c("circle","square","square","oval","rectangle",
               "circle","square","triangle","circle","oval"),
    levels = factor(c("low","medium","low","high","high","low","low","medium","high","low"))
  )
```

### Calculating the means

``` r
mean(pull(prob2_df,num_samp))
```

    ## [1] -0.2859581

``` r
mean(pull(prob2_df,greater_0))
```

    ## [1] 0.4

``` r
mean(pull(prob2_df,shapes))
```

    ## Warning in mean.default(pull(prob2_df, shapes)): argument is not numeric or
    ## logical: returning NA

    ## [1] NA

``` r
mean(pull(prob2_df,levels))
```

    ## Warning in mean.default(pull(prob2_df, levels)): argument is not numeric or
    ## logical: returning NA

    ## [1] NA

We can see that we are unable to take the mean of the character and
factor vectors, only the numeric and logical vectors produced a mean.

### Using as.numeric

``` r
as.numeric(pull(prob2_df,greater_0))
as.numeric(pull(prob2_df,shapes))
as.numeric(pull(prob2_df,levels))
```

When you convert the logical, character, and factor variables to numeric
variables, the logical vector converts the TRUE/FALSE to 1s and 0s, the
character vector remains all NA, and the factor vector reassigns the
levels to 1,2,3.

Even after using `as.numeric` the character vector stills returns NA as
R is unable to assign numbers to words/characters. However, the logical
vector becomes all 1s and 0s, representing TRUE and FALSE respectively.
This could help us see the proportion of 1s and 0s when taking . The
factor vector reassigns the levels to 1,2,3. Although they are numeric
values now, they won’t be able to help us when taking the mean as it
does not represent the true distribution of the levels.
